# 关于Swift的函数

### 三件事情

关于函数有三件需要说明的事情

* 函数可以像 Int 或者 String 那样被赋值给变量，也可以作为另一个函数的输入参数，或者另一个函数的返回值来使用。
* 函数能够捕获存在于其局部作用域之外的变量。
* 有两种方法可以创建函数，一种是使用 func 关键字，另一种是 { }。在 Swift 中，后一种被称为闭包表达式。

#### 头等公民

第一点在之前往往被我忽略，导致很多地方没有理解。函数和变量是一致的，意味着基本上所有是变量的地方都可以换成函数

```swift
func test() -> ()->() {
    return {
        print("hello")
    }
}
```

这其实也解释了后面闭包表达式的问题，可以把函数理解为闭包，闭包其实也是函数。

#### 捕获

闭包可以捕获到当前作用域之外的变量，主要注意的是捕获的时机和捕获的实际方式。 捕获的时机是：当闭包使用的外部作用域结束，而闭包或因被返回，或作为参数传递给其他函数而存在时，闭包会自动捕获其使用的外部变量。如果使用的外部变量的作用域未结束，那么闭包知识简单的使用这些外部变量，并不进行捕获。 对于值类型的数据，捕获会进行一份copy；对于引用类型，捕获会获取一份对该数据的引用，也就是对这份数据的引用+1，并且是强持有。因此，前者被捕获的数据和源数据是独立的，彼此不会影响；后者会共享同一份数据，如果其中一个放弃了引用，比如说置为nil，另一个依旧可以进行访问。

#### 闭包表达式

闭包表达式项目中用的很多，有些写法也很简洁，理解这些写法的演变过程就明白了。

```swift
var m = [1,2,3]

let m1 = m.map({(i: Int) -> Int in return 2*i})
let m2 = m.map({i in 2*i})
let m3 = m.map({$0 * 2})
let m4 = m.map(){$0 * 2}
let m5 = m.map{$0 * 2}
```

m1是最原始的写法，从m1到m2是因为swift可以自己推断类型，m3是因为函数的参数可以默认的写为`$0`这样的样式，m4是因为闭包可以尾随在`()`的后面，最后可以省略。

### 计算属性

计算属性与其他方法不同，它并不使用空间去存储计算的值。而是每一次调用的时候再去计算属性。

#### get set属性

```swift
var _m: Int = 0
var m : Int {
    get{
        print("get")
        return _m
    }
    set{
        print("set")
        _m = newValue
    }
}
```

一般来说，get set适用的场景或许更应该是给那些“根据别的变量来给自己赋值的”的变量。比如说要展示VIP的样式，要通过用户是否付费来判断是不是VIP，这样的变量和另一种变量强相关，而且如果单独写在外面的话需要if else。getset可以处理这种情况。

注意不要在getset里面return 自己，会循环crash掉。赋值的时候newValue默认会替代外部更改的值。

#### willSet didSet

这两个属性是用来观察的，比如说我希望等到一个变量改变后，再去做一些处理。这两个属性就可以方便的完成。触发的时机分别是改变发生前和改变发生后。初始化方法的时候不会调用。

