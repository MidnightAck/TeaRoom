# 快速排序

快速排序可以说是应用最为广泛的算法了，我们可以给出一个命题**快速排序是最快的通用排序算法，在大多数实际情况下，快速排序是最好的选择**。

它引人注意的特点包括原地排序，只使用一个很小的辅助栈，且时间复杂度可以稳定在`O(NlogN)`级别。其他的算法鲜有将这两个优点结合在一起。唯一的问题在于，快速排序非常脆弱，它和数据的输入有着莫大的关系，使用者必须十分小心才能避免出现低劣的性能。

### 思路

这一部分不再赘述，关于快速排序的文章可以说遍地都是。我们总结下来就是**递归的切分**。我们不妨直接看快排的伪代码：

```text
void sort(Comparable a[]){
    shuffle(a);    //随机化数组
    sort(a,0,a.size()-1);
}

void sort(Comparable a[],int low,int high){
    uf(low>high)    return;
    int j = partiton(a,low,high);
    sort(a,low,j-1);
    sort(a,j+1,high);
}
```

这里的`shuffle`操作实际上是将数组打乱成随机的数组，我们将在稳定性里面讲到它。

切分可以说是快速排序中的重点，我们这里直接写上一份正确的，可直接使用的切分函数。往往在面试中由于较大的压力，边界条件处理十分可能出现问题。需要提醒的是，要注意移动左右的顺序，先动右边，再动左边。

```text
int partiton(Comparable a[],int low,int high){
    if(low>high)    return high;
    Comparable temp=a[low];
    while(low<high){
        while(low<high&&a[high]>temp)   —high;
        if(low<high)    a[low++]=a[high];
        while(low<high&&a[low]<=temp)   ++low;
        if(low<high)    a[high--]=a[low];
    }
    a[low]=temp;
    return high;
}
```

### 性能

快速排序的优势在于两点：其一是他具有简单的内循环，内循环通过下标比对，并且不需要额外的数据移动。归并排序和希尔排序并不具备这样的功能；其二是他的比较次数较少，当然这还是取决于切分。如果切分恰好每次都切分为相等数量的两半，那快排的时间复杂度将非常好。

这里我们不得不提到快排最差和最好的情况，在我面试腾讯的时候也问到了这个问题。最好的情况毫无疑问的分成对称的两侧，这样可以类似于归并，时间复杂度在`O(NlogN)`。最差情况自然是两边差距很大，比方说这个数组本身就有序，那么我们每次切分都只能排序一个值，这样的复杂度就在平方级。当然了，我们这里讨论的是无重复数组。

总的来说，可以肯定的是对于大小为N的数组，快速排序（上面的实现方式）的运行时间在`1.39NlgN`的某个常数因子范围之内。归并排序也可以保证这一点，但是快速排序会更快（虽然他有更多次数的比较），因为他的移动数据的次数要更少。

### 优化

尽管快速排序是非常迷人的算法，但我们可以通过多种改造方式来提升他的性能。

#### 在小数据量时切换到插入排序

插入排序可以说是小数据量的万金油，我们在归并排序时也见过它。这里的小数据量定值值得商榷，再《算法》第四版中给出的参考为5-15之间，在STL::sort中，对元素少于32的数组使用插入排序。

#### 三取样切分

快速排序的最好情况是均分，一种方法是取一段数据的中位数来进行切分，代价是要计算中位数。通常的做法是取样大小设为3并用居中的元素进行切分。

但即使这样，试图将数组均分的代价往往会使整个算法本末倒置。

#### 荷兰国旗三向切分

实际应用中会出现对大量重复数据的排序，比方说性别、生日、地址等数据。这种情况下有很大的改进空间：一个全部重复的数组就不用排序。这样可以大大减少切分的次数，将切分过程中的线性对数降低为线性。

一种思路是Dijkstra的荷兰国旗问题，这个问题可以见[力扣](https://leetcode-cn.com/problems/sort-colors/)。简而言之就是将一个充满0，1，2的数组，升序排序。三向切分的方法实际上就是双指针，通过`O(N)`的时间解决。

这里我们也直接给出一个能运行起来的代码

```text
void QuickSort3way(vector<int> &nums,int low,int high){
    if(low>=high)   return;
    int lt=low,i=low+1,gt=high;
    int temp=nums[low];
    while(i<=gt){
        if(nums[i]<temp)    swap(nums[lt++],nums[i++]);
        else if(nums[i]>temp)   swap(nums[i],nums[gt—]);
        else ++i;
    }
    QuickSort3way(nums,low,lt-1);
    QuickSort3way(nums,gt+1,high);
    return;
}
```

可以看到中间的部分实际上就是荷兰国旗问题的核心代码，在大量重复数字时，这样做可以显著的减少切分的数据的长度。

在这里有必要进行一点数学讨论，我们首先给出一个命题：

> 对于大小为N的数组，三向切分的快速排序需要`~(2ln2)NH`次比较。其中H为由主键值出现频率定义的香农信息量。  
> 这里请注意，三向切分的最差情况，就是所有主键都不相等，即香农信息量最大为`lgN`。这时我们发现时间复杂度等于前文所述的普通快速排序。对于大量重复元素的数组，他将排序时间从线性对数降低到线性。
>
> #### 随机化
>
> 我们上述的所有方法，都建立在一个前提上：在排序之前随机化数组。快速排序最担心的就是全部有序的情况，随机化可以在排序前避免这种情况。

### Tips

没有一种基于比较的排序可以在少于`~NlgN`的次数内将长度为N的数组排序。

随机化数组似乎占用了排序的大块时间，但这是值得的，它能够防止最差情况并且对运行时间进行预测。

从归并排序开始，似乎我们将注意力放在重复元素上很多。但这个问题曾被忽视了数十年（参考《算法》第四版），使得一些老的算法在这个问题面前变得乏力。因此对这种问题的改进是有意义的。

